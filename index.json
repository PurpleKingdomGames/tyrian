[
{
	"uri": "https://purplekingdomgames.github.io/tyrian/installation/",
	"title": "Setup &amp; Configuration",
	"tags": [],
	"description": "",
	"content": "Installation Tyrian is a Scala 3 Web UI library, so please set your Scala version to 3.1.1 or higher.\n You can use Tyrian with Scala 2 thanks to cross versions and the magic of TASTy.\n Please note that both the sbt and Mill instructions below assume you intend to work with some sort of web packager/bundler, and therefore emit common js modules.\nThe examples in the Tyrian repo almost all use Parcel.js as the bundler.\nsbt Add the Scala.js plugin to your project/plugins.sbt file.\naddSbtPlugin(\u0026#34;org.scala-js\u0026#34; % \u0026#34;sbt-scalajs\u0026#34; % \u0026#34;1.8.0\u0026#34;) Enable the plugin and add the Tyrian library to your build.sbt file.\nenablePlugins(ScalaJSPlugin) libraryDependencies ++= Seq( \u0026#34;io.indigoengine\u0026#34; %%% \u0026#34;tyrian\u0026#34; % \u0026#34;0.3.0\u0026#34; ) scalaJSUseMainModuleInitializer := true, scalaJSLinkerConfig ~= { _.withModuleKind(ModuleKind.CommonJSModule) } Optionally, you can also include the Tyrian/Indigo Bridge library if you plan to embed an Indigo game in your page:\nlibraryDependencies ++= Seq( ... \u0026#34;io.indigoengine\u0026#34; %%% \u0026#34;tyrian-indigo-bridge\u0026#34; % \u0026#34;0.3.0\u0026#34; ) Mill Below is a complete, basic Mill build.sc file including MUnit for testing.\nimport $ivy.`com.lihaoyi::mill-contrib-bloop:$MILL_VERSION` import mill._ import mill.scalalib._ import mill.scalajslib._ import mill.scalajslib.api._ object counter extends ScalaJSModule { def scalaVersion = \u0026#34;3.1.1\u0026#34; def scalaJSVersion = \u0026#34;1.8.0\u0026#34; def ivyDeps = Agg(ivy\u0026#34;io.indigoengine::tyrian::0.3.0\u0026#34;) override def moduleKind = T(mill.scalajslib.api.ModuleKind.CommonJSModule) override def useECMAScript2015 = T(true) // required for the tyrian/indigo bridge  object test extends Tests { def ivyDeps = Agg(ivy\u0026#34;org.scalameta::munit::0.7.29\u0026#34;) def testFramework = \u0026#34;munit.Framework\u0026#34; override def moduleKind = T(mill.scalajslib.api.ModuleKind.CommonJSModule) override def jsEnvConfig = T(JsEnvConfig.NodeJs(args = List(\u0026#34;--dns-result-order=ipv4first\u0026#34;))) override def useECMAScript2015 = T(true) } } Optionally, you can also include the Tyrian/Indigo Bridge library if you plan to embed an Indigo game in your page:\ndef ivyDeps = Agg( ivy\u0026#34;io.indigoengine::tyrian::0.3.0\u0026#34;, ivy\u0026#34;io.indigoengine::tyrian-indigo-bridge::0.3.0\u0026#34; ) "
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/architecture/",
	"title": "Architecture &amp; Patterns",
	"tags": [],
	"description": "",
	"content": "The Elm Architecture Tyrian provides a runtime environment for executing applications that was originally designed according to the Elm architecture.\nElm is the name of a language and an ecosystem, but it\u0026rsquo;s architecture has become more widely known as the \u0026lsquo;TEA Pattern\u0026rsquo; ((T)he (E)lm (A)rchitecture) and has influenced many GUI/UI libraries and implementations beyond the world of functional programming.\nThe TEA pattern The TEA Pattern is about:\n Immutable data. Pure functions. Uni-directional data flow. Strictly ordered events and updates.  This gives you a system that is very easy it reason about, since the data cannot (or is unlikely to) be subject to hard-to-test race conditions or side effects, and everything happens in a predictable order.\nThe purity of the system, the way that the state is held apart from the processing and rendering functions, also allows for easy testing without the need for complex mocking.\nIn essence:\n The state of the application is modeled by an immutable Model. Events that change the state of the application are modeled by an immutable Msg type. State transitions are implemented by a (Msg, Model) =\u0026gt; Model function. Finally, a Model =\u0026gt; Html[Msg] function defines how to render the state of the application in HTML.  Tyrian vs Elm As you might expect, Elm is a far richer offering that Tyrian is now, and in all likelihood ever will be. It\u0026rsquo;s been around a lot longer, and there are a lot more people working on and with Elm every day feeding into it\u0026rsquo;s design.\nHaving said that: While Elm\u0026rsquo;s architecture has taken on a life of it\u0026rsquo;s own and influenced the state of the art of functional (and even non-FP!) UI programming, Elm itself has remained somewhat niche.\nPeople tend to love Elm \u0026hellip;or hate it. A lot of that reaction can be attributed to the fact that Elm is a very opinionated language, and you either like that or you do not.\nWhat Elm\u0026rsquo;s opinionated stance buys you is an ecosystem where if your code compiles, it works! And that is an amazing thing! In the cost/benefit analysis: The benefit is an incredibly robust web development experience, at the cost of literally not being able to do anything that is not permitted (because it would break the robustness guarantees of the ecosystem).\nTyrian takes the glorious essence of Elm\u0026rsquo;s architecture, but removes almost all of the opinions \u0026hellip;and with it of course, almost all of the safety nets!\n Want to break up your code into lots of files and classes? Carry on. Want to use refined types? Ok then. Want to use Typeclasses? No problem. Want to bring in a heavyweight FP library? Sure thing. Want to talk to JavaScript directly over an FFI? Go nuts. Want to do a non-exhaustive match? I mean, you can but\u0026hellip; Want to throw a massive exception? \u0026hellip;erm \u0026hellip;sure\u0026hellip;  Be safe out there folks! ðŸ˜€\nTyrian \u0026amp; Indigo Tyrian and Indigo are siblings and both follow an interpretation of the TEA Pattern, but they grew up at different times under different influences, and so they are not exactly the same in their design.\nTyrian is designed in the same image as Elm, and for the same purpose: Building rich web apps. Indigo however is a game engine. They do have a lot of things in common:\n The APIs are all pure functions The state is immutable The data follows a uni-directional path Events/Messages are strictly ordered \u0026hellip;even the names and signatures of the API functions are similar  \u0026hellip;and so on.\nBut if you consider the life of a GUI app versus a game - in general - user interfaces don\u0026rsquo;t do anything except as a reaction to user input. Yes, there are exceptions, you can do animations, people do use Elm to make games, etc. But as a broad brush principle, most of the time your word processor or photo editing applications are doing nothing unless you are doing something with them. Hammering keys and painting with you mouse.\nGames on the other hand are normally doing things all the time. Even if the player isn\u0026rsquo;t doing anything! There will be background animations, particle effects will be firing, non-player characters will be walking around, your character will get bored and start impatiently tapping their foot.\nTwo of the main ways this difference visibly manifests itself are:\n Cmd vs Outcome The nature of your Model instance  Cmd vs Outcome The update function in Tyrian returns a (Model, Cmd) where the command is a lazily evaluated task - perhaps an HTTP call or some other side effect. Whereas in Indigo you return an Outcome, but an outcome does not allow you to directly describe actions that would need evaluation, it only captures updated values and events. If you want to make an HTTP call, there\u0026rsquo;s an event for that.\nIn Tyrian we expect that you\u0026rsquo;ll be doing a lot of out-of-band/concurrent/side-effecting work like calling web services and interacting with JS over and FFI, in Indigo we assume you mostly won\u0026rsquo;t be.\nThis has the interesting side effect that Tyrian\u0026rsquo;s update functions are referentially transparent, but Indigo\u0026rsquo;s are both referentially transparent and declarative. The former allows you to do more practical things, the latter is lighter and easier to test, but less clean if you do need to, say, call down to JavaScript.\nThe nature of your Model What is in your model?\nIn a GUI app, your model is probably quite close to representing the things that will be displayed. Perhaps it holds the current state of a quiz or survey for example, or the items in a todo list.\nIn an Indigo game, the model tends to be much more abstract and divorced from any presentation concerns. So much so that Indigo has an extra model called a ViewModel that behaves more like a model in Tyrian.\nAs an example: Consider the score counter on a pinball machine. What makes these fun is that they do not simply show your score, they rapidly roll through the numbers always trying to keep up with your score!\nWe have two things we have to know to draw this effect:\n The real score the player has achieved. The score currently being shown.  In Tyrian, both of these values would be held in the Model. In Indigo, the real score (1) would be held in the Model as it\u0026rsquo;s a factual piece of data, while the currently displayed score would live in the ViewModel since it\u0026rsquo;s purely there for presentation purposes.\n"
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/concepts/",
	"title": "Core Concepts",
	"tags": [],
	"description": "",
	"content": "Core Concepts This section covers the key features and functions of Tyrian.\n"
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": "Examples We have a number of examples to help you get started with Tyrian, instructions on how to run them can be found in the README file under the examples folder in the repo.\n"
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/information/",
	"title": "Information &amp; Trivia",
	"tags": [],
	"description": "",
	"content": "Discussion If you\u0026rsquo;re new to the territory, we highly recommend this thoughtful blog post by Laminar\u0026rsquo;s author, Nikita Gazarov.\nThere is a point in that post where Nikita says the following:\n (..) and having now walked the path myself I finally understood exactly what that reason was: functional reactive programming (FRP) and virtual DOM don\u0026rsquo;t mix!\nVirtual DOM and FRP solve the exact same problem â€“ efficiently keeping the rendered DOM in sync with application state â€“ but they approach it from entirely opposite directions (..)\n Quite right too. It\u0026rsquo;s an important fork in the road. One direction takes you to FRP and Laminar, the other to Virtual DOM like Tyrian and Elm. Both are equally valid choices with quite subtle trade-offs.\nBroadly the argument for FRP is speed, as updates are minimal and precise. The argument for Virtual DOM is that it\u0026rsquo;s easier to test and reason about.\nHowever, You don\u0026rsquo;t have to look hard to find counter arguments to both positions: Elm is blazing fast, and Laminar has solved the classic diamond problem. \u0026hellip;but that\u0026rsquo;s the general argument.\nIn the end, it\u0026rsquo;s mostly personal preference.\nProvenance, and a note of thanks Tyrian was originally a fork of Scalm by Julien Richard-Foy.\nScalm was the Scala.js library I\u0026rsquo;d been looking for but found too late, and it\u0026rsquo;s great fun! In my opinion it was simply ahead of its time, and alas the original authors and contributors had moved on to pastures new long before it was brought to my attention.\nScalm was forked and re-released it under a new name and licence with the original authors blessing, partly because I wanted to take it in my own direction without corrupting the original work, and partly \u0026hellip;because I just wasn\u0026rsquo;t sure how to pronounce Scalm! (I did ask.)\nScalm/Tyrian and Indigo (which I also look after) are kindred spirits, in that they both follow the TEA pattern (The Elm Architecture), which is the only frontend architecture pattern I\u0026rsquo;m interested in these days.\nI hope to use Tyrian to complement Indigo, and so have brought it in under the same organisation.\nTyrian is Scalm with the cobwebs blown off. All it\u0026rsquo;s libraries are up to date, I\u0026rsquo;ve started expanding the API, and it will only ever be released against Scala 3 (and beyond!).\nWith huge thanks to the original authors,\nDave, 5th June 2021\n\u0026ldquo;Tyrian\u0026rdquo; Purple  \u0026ldquo;It took tens of thousands of desiccated hypobranchial glands, wrenched from the calcified coils of spiny murex sea snails before being dried and boiled, to colour even a single small swatch of fabric, whose fibres, long after staining, retained the stench of the invertebrate\u0026rsquo;s marine excretions. Unlike other textile colours, whose lustre faded rapidly, Tyrian purple \u0026hellip; only intensified with weathering and wear â€“ a miraculous quality that commanded an exorbitant price, exceeding the pigment\u0026rsquo;s weight in precious metals.\u0026rdquo; ~ BBC\n So it\u0026rsquo;s a purple dye that smells of where it came from and gets richer over time with use. Perfect.\n"
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/concepts/guided-tour/",
	"title": "A Guided Example",
	"tags": [],
	"description": "",
	"content": "The normal use case for Tyrian is to build a Single Page App/Application (SPA). You can also use Tyrian for Server-side Rendering (SSR), but this page will focus on SPAs.\nA guided example Let\u0026rsquo;s walk through an example to see what goes into a Tyrian App.\nThe \u0026lsquo;counter\u0026rsquo; is a very common example you\u0026rsquo;ll come across for many frameworks, it\u0026rsquo;s a handy Rosetta stone for when you need to orientate yourself in a new framework quickly.\nThe example is comprised of two buttons, + and -, and some text that shows a count that goes up and dow when you press the buttons.\nCounter Code The version of this in the examples is already quite lean, but the version below has been stripped back to the minimum.\nimport tyrian.Html.* import tyrian.* import scala.scalajs.js.annotation.* @JSExportTopLevel(\u0026#34;TyrianApp\u0026#34;) object Main extends TyrianApp[Msg, Model]: def init(flags: Map[String, String]): (Model, Cmd[Msg]) = (0, Cmd.Empty) def update(msg: Msg, model: Model): (Model, Cmd[Msg]) = msg match case Msg.Increment =\u0026gt; (model + 1, Cmd.Empty) case Msg.Decrement =\u0026gt; (model - 1, Cmd.Empty) def view(model: Model): Html[Msg] = div()( button(onClick(Msg.Decrement))(\u0026#34;-\u0026#34;), div()(model.toString), button(onClick(Msg.Increment))(\u0026#34;+\u0026#34;) ) def subscriptions(model: Model): Sub[Msg] = Sub.Empty type Model = Int enum Msg: case Increment, Decrement Lets go through it\u0026hellip;\nTyrianApp import tyrian.Html.* import tyrian.* import scala.scalajs.js.annotation.* @JSExportTopLevel(\u0026#34;TyrianApp\u0026#34;) object Main extends TyrianApp[Msg, Model]: Here we have the most common imports that bring in all the basics you\u0026rsquo;ll need to build your SPA.\nAll Tyrian SPAs must extend TyrianApp which is parameterized by a message type and a model type. These types can be anything you like, but typically Msg is an enum or ADT, and Model is probably a case class (in our case we\u0026rsquo;re just using an Int, but we\u0026rsquo;ll come back to that).\nExtending TyrianApp[Msg, Model] will produce helpful compile errors that will tell you all the functions you need to implement, i.e. init, update, view and subscriptions.\nThe other thing you must do is export the app using Scala.js\u0026rsquo;s @JSExportTopLevel(\u0026quot;TyrianApp\u0026quot;). You can call it anything you like, but all the examples expect the name \u0026ldquo;TyrianApp\u0026rdquo;.\nThe model type Model = Int Our app is a counter, so we need a number we can increment and decrement. In this super simple example, an Int is all that we need for our whole model. Normally you\u0026rsquo;d probably have a case class or something instead. To make it fit nicely, we\u0026rsquo;ve allocated our Int to a Model type alias.\n The version in the examples uses an opaque type, but here we\u0026rsquo;ve reduced it to a type alias.\n To use our model, we\u0026rsquo;re going to have to initialize it!\ndef init(flags: Map[String, String]): (Model, Cmd[Msg]) = (0, Cmd.Empty) There\u0026rsquo;s a few things going on here, the only bit we really care about here is the 0 because that is going to be the starting value of our \u0026lsquo;model\u0026rsquo;.\nSome of the other things you can see here:\n flags - Flags can be passed into the app at launch time, think of them like command line arguments. Cmd[Msg] - Commands aren\u0026rsquo;t used in the example, but they allow you to capture and run side effects and emit resulting events. They are a requirement for the function signature, and here we satisfy that with Cmd.empty.  Rendering the page Let\u0026rsquo;s draw the page. All the functions in Tyrian are encouraged to be pure, which means they operate solely on their arguments to produce a value.\nThe view takes the latest immutable (read-only) model, and produces some HTML in the form of Html[Msg].\ndef view(model: Model): Html[Msg] = div( button(\u0026#34;-\u0026#34;), div(model.toString), button(\u0026#34;+\u0026#34;) ) Here we make a div, add a - button, the another div containing the count (i.e. the model) as plain text, and finally another + button. If you\u0026rsquo;re familiar with HTML this should all look pretty familiar.\nIf you wanted to add an id attribute to the div, you would do so like this:\ndiv(id := \u0026#34;my container\u0026#34;)(...) Of course a button isn\u0026rsquo;t much use unless it does something, and what we can do is emit an event, called a message, when the button is clicked. For that we need to declare our message type which we\u0026rsquo;ll do as a simple enum that represents the two actions we want to perform:\nenum Msg: case Increment, Decrement \u0026hellip;and add our click events:\ndef view(model: Model): Html[Msg] = div( button(onClick(Msg.Decrement))(\u0026#34;-\u0026#34;), div(model.toString), button(onClick(Msg.Increment))(\u0026#34;+\u0026#34;) )  Note the return type of view is Html[Msg]. This is because unlike normal JavaScript, the onClick is not directly instigating a normal callback, the HTML elements are mapped through and produce messages as values that are passed back to Tyrian.\n Updating the counter\u0026rsquo;s value The final thing we need to do is react to the messages the view is sending, as follows:\ndef update(msg: Msg, model: Model): (Model, Cmd[Msg]) = msg match case Msg.Increment =\u0026gt; (model + 1, Cmd.Empty) case Msg.Decrement =\u0026gt; (model - 1, Cmd.Empty) Recall that our \u0026lsquo;model\u0026rsquo; is just a type alias for an Int, so all we do is match on the Msg enum type, and either increment or decrement the model - done!\nSubscriptions Subscriptions are part of the standard requirements, but this example doesn\u0026rsquo;t use them for anything. They allow you to \u0026ldquo;subscribe\u0026rdquo; to processes that emit events over time.\n"
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/concepts/bundling/",
	"title": "Building &amp; Bundling",
	"tags": [],
	"description": "",
	"content": "The JavaScript community don\u0026rsquo;t like to use the word \u0026lsquo;compiler\u0026rsquo;, but tools that gather, parse, and link source files into deployable \u0026lsquo;bundles\u0026rsquo; are an essential part of modern web app development.\nThese tools are called \u0026lsquo;bundlers\u0026rsquo;, the most famous of which is probably Webpack. It is beyond the scope of these docs to explain how bundlers work, but they are well documented tools.\nTyrian needs bundlers too. We could probably manage without them just for our raw app, but inevitably we\u0026rsquo;ll need images, and style sheets, and font files, and other JS libraries and so on. Bundlers also give you access to things like dev-servers that feature hot-reloading (i.e. your website refreshes when you re-compile your Tyrian app) which is great during development.\nI\u0026rsquo;ve already mentioned that Webpack is the most well know bundler, and Scala.js has an sbt based bundler that uses Webpack under the covers. We have a standalone example of using Tyrian with scalajs-bundler you can look at, and we also use it in our server based example.\nAll of the other examples use Parcel.js. This is because Webpack is very config heavy and scary, while Parcel is almost zero config.\nNeither solution is perfect. Use whatever suits your needs best.\n"
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/concepts/goodies/",
	"title": "Built-in Goodies",
	"tags": [],
	"description": "",
	"content": "Tyrian comes with a number of handy functions built-in that you can make use of and explore:\nBuilt-in Cmd goodies These nuggets of functionality are used as commands.\n Http.send - Makes and HTTP request that returns the respose as a message. FileReader - Given the id of a file input field that has had a file selected, this Cmd will read either an image or text file to return an HTMLImageElement or String respectively. ImageLoader - Given a path, this cmd will load an image and return an HTMLImageElement for you to make use of. Logger - A simple logger that logs to the Browsers console with a few standard headers and the log message. Random - A Cmd to generate random values.  Built-in Pub/Sub goodies These entries form a pub/sub relationship where you are required to store an object that holds state in your app\u0026rsquo;s model, and which allows you to then subscribe to events and publish messages via given Subs and Cmds respectively.\n WebSocket - Allows you to send and receive data to/from a socket server. TyrianIndigoBridge - Allows your Tyrian app to communicates with embedded Indigo games.  "
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/concepts/cmd/",
	"title": "Commands &amp; Effects",
	"tags": [],
	"description": "",
	"content": "Commands Using Tyrian, you can get a long way with nothing more than a model, a view, and some messages being pumped around their endless one-way circuit.\nHowever, sooner or later you are going to want to do something that appears to break the loop, for instance:\n Make an HTTP call Log a message to the console Invoke a download Draw to a canvas  These kinds of actions are called \u0026lsquo;side-effects\u0026rsquo;, and are an extremely popular talking point with functional programmers, because they represent the very moment that all their beautiful functional purity goes right out the window.\nLuckily, Tyrian has a pretty elegant solution for this.\nMonadic effect handling  You can skip this bit of context if you like. This section has a bit of jargon in it for those who care about such things, but it\u0026rsquo;s really not important if you just want to know how to use commands.\n The usual approach to handling effects (short for side effects) is to employ some sort of effect monad that captures your side effect as a lazy value.\nThis is exactly what a command (Cmd) does. While commands themselves are only Monoidal Functors*, they work using a Monadic Task implementation under the covers.\n(* Meaning you can map over them, they can be combined togetherm and have an empty state Cmd.empty.)\nSo far, this is sounding like effect handling as usual. But no. Primarily because you never (or rarely) actually see the underlying Task.\nMaking things happen Commands take the form Cmd[Msg] which is to say that they represent some sort of side effect that can produce a message to be cleanly fed back into your single page application\u0026rsquo;s updateModel function.\nCommands can be produced as part of a result of calling the init or updateModel functions, which both return a (Model, Cmd[Msg]).\nHere is an example in which, on receiving a message Msg.LogThis, we are not going to change the model, but we want to write to the browser\u0026rsquo;s JavaScript console:\nimport tyrian.* import tyrian.cmds.* type Model = Int enum Msg: case LogThis(message: String) def update(msg: Msg, model: Model): (Model, Cmd[Msg]) = msg match case Msg.LogThis(msg) =\u0026gt; (model, Logger.consoleLog(msg)) To achieve this, we use the Logger command that comes with Tyrian. The Logger command is in fact just a Cmd.SideEffect that captures a value or behavior as a zero argument function, known as a thunk, in this case a simplified implementation could just be:\ndef consoleLog(msg: String): Cmd[Nothing] = Cmd.SideEffect { () =\u0026gt; println(msg) } But commands can also return values in the form of messages. The Random command looks like this:\nRandom.double \u0026hellip;and produces an instance of RandomValue, but this leads to a problem since RandomValue is almost certainly not your app\u0026rsquo;s Msg type, and so we must map over the result:\nenum MyMsg: case MyRandom(d: Double) extends MyMsg case Error extends MyMsg Random.double.map { case RandomValue.NextDouble(d) =\u0026gt; MyMsg.MyRandom(d) case _ =\u0026gt; MyMsg.Error } These are simple examples, but there are much more complicated uses for commands. One great use of commands is for making HTTP requests where the response is decoded into a Msg.\n"
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/concepts/networking/",
	"title": "Networking",
	"tags": [],
	"description": "",
	"content": "Out of the box, Tyrian supports two flavors of networking, HTTP and Web Sockets, and we have examples you can run of both. Please see the instructions in the README file.\nIt should be said that both implementations are quite primitive at the time of writing. Contributions in the form of issues and improvements are very welcome in this area. No doubt the will be improved as the need arises.\n"
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/concepts/ssr/",
	"title": "Server-side Rendering (SSR)",
	"tags": [],
	"description": "",
	"content": "What is server-side rendering? These days, a normal straight-forward relationship between a frontend client and some sort of backend service, is that the client makes an HTTP request to the service, and receives some data back that it uses to render a page/view for the user. But it wasn\u0026rsquo;t always so!\nBack in the days when Perl dominated the world of server side technology and ASP was new and exciting, it was more normal for the browser to hit a url, and for the page rendering to happen entirely on the server: The HTML delivered whole and fully formed to the browser. This allow the pages to be built up from data pulled from other services and databases.\nThis arrangement has come back into fashion, and now has the fancy name \u0026ldquo;server-side rendering\u0026rdquo; or SSR. The benefit of SSR is that HTML is incredibly cache-able. If you can manufacture a page or a fragment of a page once, then you may be able to cache it for super fast page loading performance.\nSimple SSR with Tyrian Below is a simple example of SRR with Tyrian:\nimport tyrian.* import tyrian.Html.* val styles = style(CSS.`font-family`(\u0026#34;Arial, Helvetica, sans-serif\u0026#34;)) val topLine = p(b(text(\u0026#34;HTML fragment rendered by Tyrian on the server.\u0026#34;))) Tyrian.render( div(styles)( topLine, p(\u0026#34;Hello, world!\u0026#34;) ) ) As you can see, this is completely ordinary Scala, which means you can do anything that Scala lets you do in order to generate this HTML block, without having to learn a templating language like Mustache.\nThere are a number of variations of the Tyrian.render function, full details can be found in the Tyrian API docs.\nThere is an example of SRR in the server-examples.\n"
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/concepts/subs/",
	"title": "Subscriptions",
	"tags": [],
	"description": "",
	"content": "Subscriptions: A notification of change Subscriptions (Subs) are used to observe something that changes over time, and to emit discrete messages when something happens.\nFor example, we could chose to observe the mouse position, and emit a message every time the mouse moves, like this:\nimport org.scalajs.dom.document import org.scalajs.dom.MouseEvent import tyrian.* type Model = ??? enum Msg: case MouseMove(x: Double, y: Double) val mousePosition: Sub[Msg] = Sub.fromEvent(\u0026#34;mousemove\u0026#34;, document) { case e: MouseEvent =\u0026gt; Option(Msg.MouseMove(e.pageX, e.pageY)) } def subscriptions(model: Model): Sub[Msg] = mousePosition A change in mouse position will now result in a MouseMove message that will be piped back to your updateModel function.\nSubscriptions can be used on their own, or in conjunction with commands to form a pub/sub relationship with a resource, as is the case with web sockets and the tyrian-indigo bridge.\nWorking with Subscriptions Subscriptions are Functors which means that you can map over them to change the resultant message. They are also Monoids which means that they have an empty representation Sub.empty and that you can combine them together, using combine or the shorthand operator: sub1 |+| sub2.\nA common thing to need to do is batch multiple subs together into a single subscription, like this:\nimport scala.concurrent.duration._ import org.scalajs.dom.document import org.scalajs.dom.MouseEvent import tyrian.* enum Msg: case MouseMove(x: Double, y: Double) case CurrentSeconds(seconds: Double) val mousePosition: Sub[Msg] = Sub.fromEvent(\u0026#34;mousemove\u0026#34;, document) { case e: MouseEvent =\u0026gt; Option(Msg.MouseMove(e.pageX, e.pageY)) } val tick = Sub.every(1.second, \u0026#34;tick\u0026#34;) .map(date =\u0026gt; Msg.CurrentSeconds(date.getSeconds())) def subscriptions(model: Model): Sub[Msg] = Sub.Batch( mousePosition, tick ) "
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/",
	"title": "Tyrian",
	"tags": [],
	"description": "",
	"content": "Tyrian Tyrian is an Elm-inspired, purely functional UI library for Scala 3.\nIts purpose is to make building interactive websites in Scala 3 fun! Tyrian allows you to describe web pages and complex interactions in a way that is elegant, easy to read and easy to reason about.\nTyrian is not designed to work alone, the intention is that you will use it alongside a web bundler to look after things like your media assets and stylesheets. (All our examples use Parcel.)\nTyrian ðŸ’œ's Indigo Tyrian is by the maintainers of Indigo, a Scala 3 game engine. As such, Indigo web games are first class citizens in Tyrian, allowing easy embedding and seamless communication between their respective event/messaging systems.\nWhen should I consider using Tyrian? Tyrian is designed for building SPAs (Single Page Applications): Web pages with lots of interactive elements.\nOne use case we\u0026rsquo;re particularly excited about is augmenting Indigo games with rich HTML UI elements.\nYou can also use Tyrian to do Server-side Rendering (SSR) in conjunction with your favorite Scala HTTP framework in place of, say, a templating library.\nWhat should I avoid using Tyrian for? Tyrian is not a great candidate for static websites - like this one! - where the content is there to be read, not interacted / played / engaged with.\nWhy shouldn\u0026rsquo;t I just use some Scala.js-React-based-thingy instead? You can! Quite frankly, you probably should!\nIn fact there are a good number of Scala.js alternatives to Tyrian, such as Outwatch, scalajs-react, Slinky, and Laminar to name a few.\nReact in particular is an industry standard framework these days, and so there are lots and lots of resources out there to help you use it. In that regard at least, React (via Slinky or scalajs-react) is probably a good choice for beginners.\nFunctional programmers may be more into something like Laminar, which is based on Functional Reactive Programming (FRP). Laminar looks to be well made and well maintained, and there are some great talks out there about it.\nTyrian works fundamentally differently to those other frameworks. In the authors very opinionated opinion: The Elm Architecture upon which it is based, is the most productive, fun, and sane frontend architectural approach there is.\nThis library exists because we don\u0026rsquo;t want to work any other way. We encourage you to try a few different approaches and decide what works best for you. ðŸ˜Š\n"
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/concepts/tyrian-indigo-bridge/",
	"title": "Tyrian-Indigo Bridge",
	"tags": [],
	"description": "",
	"content": "What if you wanted to make a web game (or an Electron desktop game - why not!), where the main game window was rendered in WebGL, but the UI elements were all in lovely, responsive, scalable HTML5?\nThe main problem is how you get the two parts to talk to one another. If everything is written in JavaScript, that\u0026rsquo;s not such a problem because it\u0026rsquo;s all the same language, the two systems are likely to be idiomatically similar, and with JavaScript \u0026hellip;well, you can do pretty much anything you like.\nIf you want to use Scala.js, things get more complicated.\nTyrian ðŸ’œ's Indigo One of the reasons Tyrian was resurrected from the ashes of it\u0026rsquo;s predecessor Scalm was that we love working with this architecture pattern, the TEA pattern. Indigo our game engine, uses a variation on the same design.\nBoth use the same language\u0026hellip; both use the same idioms\u0026hellip; why not join them together?\nRunnable Example Rather than go into all the details of how it works, there is an example you can look at the demonstrates how the two can seamlessly communicate using lovely native Scala types.\n Note that the example is quite simple and just uses String as it\u0026rsquo;s message format, but you can use whatever suits your needs.\n Overview making Tyrian work with Indigo Assuming you have a skeletal Tyrian project, and right next to it in the same code base a basic Indigo game (Tip: namespacing the game to its own package is a good idea\u0026hellip; you\u0026rsquo;re about to have two models!):\nThe Bridge The way the bridge works is that the Tyrian side holds an instance of the bridge in it\u0026rsquo;s model, and Indigo runs a subsystem for that bridge.\nIndigo SubSystems are like mini-games that have most of the same functions as the main game, but can only talk via messages - sort of like background workers.\nThe Bridge is a JavaScript EventTarget, and both Indigo and Tyrian latch on. In both instances their job is to send and receive messages via the brigde event target and convert them to their native event/messaging system.\nEstablishing a connection  Indigo needs a container to latch onto, so Tyrian provides that in it\u0026rsquo;s rendered view. During init, you start up the bridge and put it in your model, then use a Cmd.Emit to tell the updateModel function to start the game. An Indigo game can then be trivially launched using a Cmd.SideEffect that literally calls your game\u0026rsquo;s launch function in plain ole Scala, injecting the bridge provided SubSystem into the game.  Important: The key tools you need are now all on your bridge instance. Your bridge instance will give you the Indigo SubSystem for you, it also has the publish Cmd and the subscribe Sub that you need.\nPublishing and Subscribing Note that Indigo uses the term \u0026lsquo;event\u0026rsquo; and Tyrian uses \u0026lsquo;message\u0026rsquo;. The behavior is slightly different between the two, but for our purposes here, they should be considered the same thing.\nIn Indigo Indigo now has a new GlobalEvent type, TyrianEvent which can be a TyrianEvent.Send(value: A) or TyrianEvent.Receive(value: A) where the A type is declared with the SubSystem.\nTo listen for messages from Tyrian, you simply match on the TyrianEvent.Receive(value: A) in one of you update functions.\nTo send a message to Tyrian, you emit a message as normal, e.g.:\nOutcome(..).addGlobalEvents(TyrianEvent.Send(myMessage)) In Tyrian Tyrian by now has a reference to the bridge in your model.\nTo listen for messages from Indigo, all you have to do is plumb in the model.bridge.subscribe Sub[Msg] into your app\u0026rsquo;s subscriptions feed, and provide an extractor to tell it how to convert the events into messages.\nTo send message to Indigo, you call bridge.send(myMsg) which provides a Cmd[Msg] for you to plug into your updateModel result.\nThat\u0026rsquo;s it! In a nutshell, that is the whole set up. Happy web game building!\n"
}]